export class GCodeExporter {
  constructor() {
    this.settings = {
      extrusionWidth: 0.4, // mm
      layerHeight: 0.2, // mm
      printSpeed: 30, // mm/s
      travelSpeed: 120, // mm/s
      extrusionMultiplier: 1.0,
      bedTemp: 60, // 째C
      nozzleTemp: 200, // 째C
      retraction: 3, // mm
      retractionSpeed: 45, // mm/s
    };
  }

  exportLine(lineObject) {
    if (!lineObject || !lineObject.geometry) {
      throw new Error("Invalid line object provided");
    }

    const positions = lineObject.geometry.attributes.position.array;
    const points = [];

    // Convert buffer geometry to Vector3 points
    for (let i = 0; i < positions.length; i += 3) {
      points.push({
        x: positions[i],
        y: positions[i + 1],
        z: positions[i + 2],
      });
    }

    const gcode = this.generateGCode(points);
    return gcode;
  }

  generateGCode(points) {
    let gcode = this.getStartGCode();

    if (points.length === 0) {
      gcode += this.getEndGCode();
      return gcode;
    }

    // Move to first point (no extrusion)
    const firstPoint = points[0];
    gcode += `; Move to start position\n`;
    gcode += `G0 F${this.settings.travelSpeed * 60} X${firstPoint.x.toFixed(
      3
    )} Y${firstPoint.y.toFixed(3)} Z${firstPoint.z.toFixed(3)}\n`;
    gcode += `G92 E0 ; Reset extruder position\n`;

    let extruderPosition = 0;

    // Generate continuous extrusion path
    gcode += `; Start printing spirograph\n`;
    for (let i = 1; i < points.length; i++) {
      const point = points[i];
      const prevPoint = points[i - 1];

      // Calculate distance for extrusion amount
      const dx = point.x - prevPoint.x;
      const dy = point.y - prevPoint.y;
      const dz = point.z - prevPoint.z;
      const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

      // Calculate extrusion amount based on distance and settings
      const extrusionAmount = distance * this.settings.extrusionMultiplier;
      extruderPosition += extrusionAmount;

      gcode += `G1 F${this.settings.printSpeed * 60} X${point.x.toFixed(
        3
      )} Y${point.y.toFixed(3)} Z${point.z.toFixed(
        3
      )} E${extruderPosition.toFixed(5)}\n`;

      // Add a comment every 100 lines for debugging
      if (i % 100 === 0) {
        gcode += `; Point ${i}/${points.length}\n`;
      }
    }

    gcode += this.getEndGCode();
    return gcode;
  }

  getStartGCode() {
    return `; Generated by 3D Spirograph App
; Print Settings:
; - Nozzle Temperature: ${this.settings.nozzleTemp}째C
; - Bed Temperature: ${this.settings.bedTemp}째C
; - Print Speed: ${this.settings.printSpeed}mm/s
; - Extrusion Width: ${this.settings.extrusionWidth}mm

M140 S${this.settings.bedTemp} ; Set bed temperature
M104 S${this.settings.nozzleTemp} ; Set nozzle temperature
M190 S${this.settings.bedTemp} ; Wait for bed temperature
M109 S${this.settings.nozzleTemp} ; Wait for nozzle temperature

; Homing and calibration
G28 ; Home all axes
G29 ; Auto bed leveling (if available)

; Prime the extruder
G92 E0 ; Reset extruder
G1 F200 E5 ; Prime extruder
G1 F${this.settings.retractionSpeed * 60} E2 ; Small retraction
G92 E0 ; Reset extruder position

`;
  }

  getEndGCode() {
    return `
; End of print
G1 E-${this.settings.retraction} F${
      this.settings.retractionSpeed * 60
    } ; Final retraction
G91 ; Relative positioning
G1 Z5 F300 ; Move bed down 5mm
G90 ; Absolute positioning
G28 X0 Y0 ; Home X and Y axes
M104 S0 ; Turn off nozzle heater
M140 S0 ; Turn off bed heater
M84 ; Disable all motors
M117 Print Complete! ; Display message
`;
  }

  downloadGCode(gcode, filename = "spirograph_3d.gcode") {
    // Add some metadata
    const timestamp = new Date().toISOString();
    const header = `; Generated on: ${timestamp}\n; Total lines: ${
      gcode.split("\n").length
    }\n\n`;
    const fullGCode = header + gcode;

    const blob = new Blob([fullGCode], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    a.style.display = "none";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    console.log(`G-Code exported: ${filename}`);
    console.log(`Total lines: ${fullGCode.split("\n").length}`);
  }

  estimatePrintTime(points) {
    if (points.length < 2) return 0;

    let totalDistance = 0;
    for (let i = 1; i < points.length; i++) {
      const current = points[i];
      const previous = points[i - 1];
      const dx = current.x - previous.x;
      const dy = current.y - previous.y;
      const dz = current.z - previous.z;
      totalDistance += Math.sqrt(dx * dx + dy * dy + dz * dz);
    }

    // Rough estimate: distance / speed + setup time
    const printTimeSeconds = totalDistance / this.settings.printSpeed + 300; // 5 min setup
    return Math.round(printTimeSeconds / 60); // Return minutes
  }
}
